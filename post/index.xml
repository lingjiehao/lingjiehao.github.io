<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Alien's Blog</title><link>https://blog.mylab.top/post/</link><description>Recent content in Posts on Alien's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 02 Mar 2022 13:57:28 +0800</lastBuildDate><atom:link href="https://blog.mylab.top/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Windows 10常见问题</title><link>https://blog.mylab.top/post/windows-10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 02 Mar 2022 13:57:28 +0800</pubDate><guid>https://blog.mylab.top/post/windows-10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid><description>1.Win10可以上网,但网络图标仍然显示感叹号 我的电脑必须通过VPN连接到代理才可以上外网, 不过即使连上VPN后可以连接外网了, 右下角的网络图标仍然有黄色感叹号, 提示&amp;quot;无法连接到Internet&amp;quot;, 可以通过注册表关闭检测网络连通性的功能.
打开注册表HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\NlaSvc\Parameters\Internet 将EnableActiveProbing改为0 https://blog.csdn.net/Unity_Ling/article/details/100121546</description></item><item><title>编译单个内核模块</title><link>https://blog.mylab.top/post/%E7%BC%96%E8%AF%91%E5%8D%95%E4%B8%AA%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/</link><pubDate>Wed, 02 Mar 2022 13:52:53 +0800</pubDate><guid>https://blog.mylab.top/post/%E7%BC%96%E8%AF%91%E5%8D%95%E4%B8%AA%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/</guid><description>环境: Ubuntu 16.04 + Android P源码
源码路径: /home/michael/android_code
需要编译的模块路径: 比如 /home/michael/test_module/, 内核模块文件名为test_module.c 那么只需要在/home/michael/test_module/中建立一个Makefile文件就可以编译这个模块了. Makefile的模板如下:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 obj-m += test_module.o # Android 源码路径 SOURCE_PATH := /home/michael/android_src # kernel 的输出目录, &amp;lt;product-name&amp;gt; 因产品而异,下文同 KDIR := $(SOURCE_PATH)/out/target/product/&amp;lt;product-name&amp;gt;/obj/KERNEL_OBJ PWD :=$(shell pwd) KERNEL_CFLAGS := KCFLAGS=-mno-android CROSS := $(SOURCE_PATH)/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin all: $(MAKE) -C $(FLAGS) $(KDIR) ARCH=arm64 CROSS_COMPILE=$(CROSS)/aarch64-linux-android- M=$(PWD) $(FLAGS) $(KERNEL_CFLAGS) modules clean: rm -f *.</description></item><item><title>Wireguard配置教程</title><link>https://blog.mylab.top/post/wireguard%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</link><pubDate>Wed, 02 Mar 2022 12:57:42 +0800</pubDate><guid>https://blog.mylab.top/post/wireguard%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</guid><description>Bypass Certain Ip https://www.reddit.com/r/WireGuard/comments/emjgp0/bypass_certain_ip_from_going_into_wireguard_tunnel/
You could replace 0.0.0.0/0 and/or ::/0 in the AllowedIPs setting with a list of ranges that cover everything but the IP ranges you want to bypass.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from ipaddress import ip_network start = &amp;#39;0.0.0.0/0&amp;#39; exclude = [&amp;#39;8.8.8.8&amp;#39;, &amp;#39;10.8.0.0/24&amp;#39;] result = [ip_network(start)] for x in exclude: n = ip_network(x) new = [] for y in result: if y.</description></item><item><title>打开edk2 fastboot在user版本下刷写分区的功能</title><link>https://blog.mylab.top/post/%E6%89%93%E5%BC%80edk2-fastboot%E5%9C%A8user%E7%89%88%E6%9C%AC%E4%B8%8B%E5%88%B7%E5%86%99%E5%88%86%E5%8C%BA%E7%9A%84%E5%8A%9F%E8%83%BD/</link><pubDate>Tue, 01 Mar 2022 22:00:45 +0800</pubDate><guid>https://blog.mylab.top/post/%E6%89%93%E5%BC%80edk2-fastboot%E5%9C%A8user%E7%89%88%E6%9C%AC%E4%B8%8B%E5%88%B7%E5%86%99%E5%88%86%E5%8C%BA%E7%9A%84%E5%8A%9F%E8%83%BD/</guid><description>在Android 10中测试有效
在user版本中, 使用fastboot flash boot boot.img会提示&amp;rsquo;Unknown command', 这是因为在user版本中, 关闭了fastboot flash的命令.
edk2版本的fastboot对应的源码路径为QcomModulePkg/Library/FastbootLib, flash 等命令在FastbootCmds.c中的cmd_list这个数组定义.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 struct FastbootCmdDesc cmd_list[] = { /* By Default enable list is empty */ {&amp;#34;&amp;#34;, NULL}, /*CAUTION(High): Enabling these commands will allow changing the partitions *like system,userdata,cachec etc... */ #ifdef ENABLE_UPDATE_PARTITIONS_CMDS {&amp;#34;flash:&amp;#34;, CmdFlash}, {&amp;#34;erase:&amp;#34;, CmdErase}, {&amp;#34;set_active&amp;#34;, CmdSetActive}, {&amp;#34;flashing get_unlock_ability&amp;#34;, CmdFlashingGetUnlockAbility}, {&amp;#34;flashing unlock&amp;#34;, CmdFlashingUnlock}, {&amp;#34;flashing lock&amp;#34;, CmdFlashingLock}, #endif /* *CAUTION(CRITICAL): Enabling these commands will allow changes to bootimage.</description></item><item><title>Android:设置recovery的默认显示方向</title><link>https://blog.mylab.top/post/android%E8%AE%BE%E7%BD%AErecovery%E7%9A%84%E9%BB%98%E8%AE%A4%E6%98%BE%E7%A4%BA%E6%96%B9%E5%90%91/</link><pubDate>Thu, 27 May 2021 19:49:45 +0800</pubDate><guid>https://blog.mylab.top/post/android%E8%AE%BE%E7%BD%AErecovery%E7%9A%84%E9%BB%98%E8%AE%A4%E6%98%BE%E7%A4%BA%E6%96%B9%E5%90%91/</guid><description>平台：Android 10
方法 recovery 的方向可以通过 ro.minui.default_rotation 这个属性来控制，ro.minui.default_rotation 在 minui/graphics.cpp 中的 gr_init() 函数被解析。
代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int gr_init() { ... std::string rotation_str = android::base::GetProperty(&amp;#34;ro.minui.default_rotation&amp;#34;, &amp;#34;ROTATION_NONE&amp;#34;); if (rotation_str == &amp;#34;ROTATION_RIGHT&amp;#34;) { gr_rotate(GRRotation::RIGHT); } else if (rotation_str == &amp;#34;ROTATION_DOWN&amp;#34;) { gr_rotate(GRRotation::DOWN); } else if (rotation_str == &amp;#34;ROTATION_LEFT&amp;#34;) { gr_rotate(GRRotation::LEFT); } else { // &amp;#34;ROTATION_NONE&amp;#34; or unknown string gr_rotate(GRRotation::NONE); } .</description></item><item><title>Ubuntu Apt命令</title><link>https://blog.mylab.top/post/ubuntu-apt%E5%91%BD%E4%BB%A4/</link><pubDate>Thu, 27 May 2021 14:01:37 +0800</pubDate><guid>https://blog.mylab.top/post/ubuntu-apt%E5%91%BD%E4%BB%A4/</guid><description>安装时默认 &amp;ndash;no-install-recommends 1 2 3 4 cat &amp;gt; /etc/apt/apt.conf.d/01norecommend &amp;lt;&amp;lt; EOF APT::Install-Recommends &amp;#34;0&amp;#34;; APT::Install-Suggests &amp;#34;0&amp;#34;; EOF https://superuser.com/questions/615565/can-i-make-apt-get-always-use-no-install-recommends</description></item><item><title>Adb常用操作</title><link>https://blog.mylab.top/post/adb%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link><pubDate>Thu, 27 May 2021 13:37:42 +0800</pubDate><guid>https://blog.mylab.top/post/adb%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid><description>1.模拟点击 模拟长按 1 adb shell input keyevent --longpress KEYCODE_L 如：
1 2 # 长按电源键 adb shell input keyevent --longpress 26</description></item><item><title>Kernel 工作队列</title><link>https://blog.mylab.top/post/kernel%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/</link><pubDate>Tue, 25 May 2021 16:35:30 +0800</pubDate><guid>https://blog.mylab.top/post/kernel%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/</guid><description>内核版本: 4.15
调度一个 work，首先需要定义一个 workqueue，然后将这个 work 放入到这个 workqueue 中。 当我们希望调度一个 work 时，可以有两种方法：
内核会为每一个 cpu 创建一个默认的 workqueue，可以用 schedule_work 函数将 work 加入到默认的 workqueue 中； 当默认的 workqueue 任务太重时，为了加快响应，我们可以自定义一个 workqueue，然后使用 queue_work 函数将 work 加入到自定义的 workqueue 中。 使用自定义的 workqueue 1 2 3 4 5 6 7 8 9 10 struct work_struct { /* atomic_long_t data; */ unsigned long data; struct list_head entry; work_func_t func; #ifdef CONFIG_LOCKDEP struct lockdep_map lockdep_map; #endif }; 使用前进行必要的初始化：</description></item><item><title>挂载img文件</title><link>https://blog.mylab.top/post/%E6%8C%82%E8%BD%BDimg%E6%96%87%E4%BB%B6/</link><pubDate>Sat, 22 May 2021 10:42:57 +0800</pubDate><guid>https://blog.mylab.top/post/%E6%8C%82%E8%BD%BDimg%E6%96%87%E4%BB%B6/</guid><description>本文主要讲解如何在Ubuntu下挂载raw image镜像，以raspberry pi官方镜像2019-04-08-raspbian-stretch-lite.img 为例
计算偏移量并手动挂载 1.使用fdisk查看分区结构 1 2 3 4 5 6 7 8 9 10 11 12 # fdisk -l Disk 2019-04-08-raspbian-stretch-lite.img: 1.7 GiB, 1803550720 bytes, 3522560 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0xc1dc39e5 Device Boot Start End Sectors Size Id Type 2019-04-08-raspbian-stretch-lite.img1 8192 96042 87851 42.</description></item><item><title>Android command-tools使用方法</title><link>https://blog.mylab.top/post/android-command-tools/</link><pubDate>Sat, 22 May 2021 10:02:03 +0800</pubDate><guid>https://blog.mylab.top/post/android-command-tools/</guid><description>下载地址： https://developer.android.com/studio/index.html#command-tools
sdkmanager的使用 下载与配置 https://stackoverflow.com/questions/60440509/android-command-line-tools-sdkmanager-always-shows-warning-could-not-create-se
command-tools 下载并加入到环境变量中后，并不能直接使用，还需要额外的配置。
新建一个android_sdk目录，并创建子目录cmdline-tools。然后创建环境变量ANDROID_SDK_ROOT，环境变量的值为android_sdk目录的路径，如
1 2 mkdir -p ~/android_sdk/cmdline-tools echo &amp;#39;export ANDROID_SDK_ROOT=~/android_sdk&amp;#39; &amp;gt;&amp;gt; ~/.bashrc 将commandlinetools-xxx-xxx_latest.zip解压，得到cmdline-tools文件夹，并重命名为tools
将上一步的tools目录移动到$ANDROID_SDK_ROOT/cmdline-tools下，现在的目录结构应该是：$ANDROID_SDK_ROOT/cmdline-tools/tools。tools目录下，会有NOTICE.txt bin lib source.properties等文件。事实上，按照官方文档，正确的目录结构应该是android_sdk/cmdline-tools/&amp;lt;version&amp;gt;/bin，不过我试过了，把&amp;lt;version&amp;gt;替换成tools也是可以用的。
配置PATH，推荐这样配置：
1 echo &amp;#39;export PATH=$PATH:$ANDROID_SDK_ROOT/cmdline-tools/latest/bin:$ANDROID_SDK_ROOT/cmdline-tools/tools/bin&amp;#39; &amp;gt;&amp;gt; ~/.bashrc 因为如果以后版本升级，sdkmanager会被放在$ANDROID_SDK_ROOT/cmdline-tools/latest/bin目录下，所以把latest目录放到较高的优先级。
通过sdkmanager安装platform tools, build tools, android sdk等工具 先使用sdkmanager &amp;ndash;list 列出所有可以下载的软件包,然后根据需要选择下载的版本。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ sdkmanager --list .</description></item><item><title>AOSP Repo及其manifest.xml简介</title><link>https://blog.mylab.top/post/aosp-repo%E5%8F%8A%E5%85%B6manifest.xml%E7%AE%80%E4%BB%8B/</link><pubDate>Fri, 21 May 2021 18:08:06 +0800</pubDate><guid>https://blog.mylab.top/post/aosp-repo%E5%8F%8A%E5%85%B6manifest.xml%E7%AE%80%E4%BB%8B/</guid><description>manifest.xml demo 示例1：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;manifest&amp;gt; &amp;lt;remote name=&amp;#34;github&amp;#34; fetch=&amp;#34;https://github.com&amp;#34;/&amp;gt; &amp;lt;remote name=&amp;#34;qcom&amp;#34; fetch=&amp;#34;https://source.codeaurora.org/quic/la&amp;#34;/&amp;gt; &amp;lt;default revision=&amp;#34;master&amp;#34; remote=&amp;#34;github&amp;#34;/&amp;gt; &amp;lt;project name=&amp;#34;raspberrypi/linux&amp;#34; path=&amp;#34;rpi-linux-4.19&amp;#34; revision=&amp;#34;rpi-4.19.y&amp;#34;/&amp;gt; &amp;lt;project name=&amp;#34;raspberrypi/linux&amp;#34; path=&amp;#34;rpi-linux-5.4&amp;#34; revision=&amp;#34;rpi-5.4.y&amp;#34;/&amp;gt; &amp;lt;project name=&amp;#34;torvalds/linux&amp;#34; path=&amp;#34;torvalds-linux-latest&amp;#34; revision=&amp;#34;master&amp;#34;/&amp;gt; &amp;lt;project name=&amp;#34;MiCode/Xiaomi_Kernel_OpenSource&amp;#34; path=&amp;#34;xiaomi-kernel-k20pro&amp;#34; revision=&amp;#34;cepheus-q-oss&amp;#34;/&amp;gt; &amp;lt;!-- qcom --&amp;gt; &amp;lt;project name=&amp;#34;kernel/msm-4.19&amp;#34; path=&amp;#34;msm-4.19&amp;#34; remote=&amp;#34;qcom&amp;#34; revision=&amp;#34;aosp-new/android-4.19-stable&amp;#34;/&amp;gt; &amp;lt;!-- &amp;lt;project name=&amp;#34;openwrt-custom&amp;#34; path=&amp;#34;custom&amp;#34;&amp;gt; --&amp;gt; &amp;lt;!-- &amp;lt;linkfile dest=&amp;#34;build.sh&amp;#34; src=&amp;#34;build.sh&amp;#34;/&amp;gt; --&amp;gt; &amp;lt;!-- &amp;lt;/project&amp;gt; --&amp;gt; &amp;lt;/manifest&amp;gt; 示例2：</description></item><item><title>Git常用操作</title><link>https://blog.mylab.top/post/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link><pubDate>Fri, 21 May 2021 15:53:57 +0800</pubDate><guid>https://blog.mylab.top/post/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid><description>1.如何删除远程仓库上的分支/tag https://stackoverflow.com/questions/2003505/how-do-i-delete-a-git-branch-locally-and-remotely https://stackoverflow.com/questions/5480258/how-to-delete-a-remote-tag
删除远程仓库上的分支 1 2 $ git push -d &amp;lt;remote_name&amp;gt; &amp;lt;branch_name&amp;gt; $ git branch -d &amp;lt;branch_name&amp;gt; Note that in most cases the remote name is origin. In such a case you&amp;rsquo;ll have to use the command like so.
1 $ git push -d origin &amp;lt;branch_name&amp;gt; 删除远程仓库的tag同理 1 git push --d origin tagname 如果还需要删除本地的tag，那么
1 git tag -d tagname</description></item><item><title>Docker常用操作</title><link>https://blog.mylab.top/post/docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link><pubDate>Sun, 09 May 2021 10:04:13 +0800</pubDate><guid>https://blog.mylab.top/post/docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid><description>docker 安装 1 2 3 curl -sSL get.docker.com | sudo bash -s -- --mirror Aliyun # 或者使用 wget wget -qO- get.docker.com | sudo bash -s -- --mirror Aliyun docker-compose安装 通过apt安装的docker-compose版本太老，所以还是使用官网的方式安装。
下载
1 sudo curl -L &amp;#34;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&amp;#34; -o /usr/local/bin/docker-compose 添加可执行权限
1 sudo chmod +x /usr/local/bin/docker-compose 添加bash-completion（可选）
1 2 3 sudo curl \ -L https://raw.</description></item><item><title>Vim常用操作</title><link>https://blog.mylab.top/post/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 24 Apr 2021 15:44:48 +0800</pubDate><guid>https://blog.mylab.top/post/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid><description>编辑二进制文件 https://vi.stackexchange.com/questions/343/how-to-edit-binary-files-with-vim
打开并编辑二进制文件, 可以使用 xxd 命令
1 xxd test.bin | vim - 如果这个二进制文件已经被 vim 打开(一般显示为乱码), 则重载这个文件
1 :%!xxd 保存为二进制
1 :%!xxd -r &amp;gt; new-file.bin 删除行末的^M https://unix.stackexchange.com/questions/32001/what-is-m-and-how-do-i-get-rid-of-it https://stackoverflow.com/questions/5843495/what-does-m-character-mean-in-vim
1 :s/^M$// 先输入Ctrl+V,然后输入Ctrl+M来输入^M</description></item><item><title>Systemd Daemon示例</title><link>https://blog.mylab.top/post/systemd-daemon%E7%A4%BA%E4%BE%8B/</link><pubDate>Sat, 03 Apr 2021 18:34:55 +0800</pubDate><guid>https://blog.mylab.top/post/systemd-daemon%E7%A4%BA%E4%BE%8B/</guid><description>1.新增service文件 vi /lib/systemd/system/jupyter-notebook.service
1 2 3 4 5 6 7 8 9 10 11 12 13 [Unit] Description=IPython notebook [Service] Type=simple PIDFile=/var/run/ipython-notebook.pid ExecStart=/home/xyz/.local/bin/anaconda/bin/jupyter-notebook --no-browser User=xyz Group=xyz WorkingDirectory=/home/xyz/work/jupyter [Install] WantedBy=multi-user.target 2.开机启动 1 sudo systemctl enable jupyter-notebook.service 3.启动服务 1 sudo systemctl start jupyter-notebook.service 2,3两步可以合为一步sudo systemctl enable jupyter-notebook.service --now
https://stackoverflow.com/questions/14297741/how-to-start-ipython-notebook-server-at-boot-as-daemon</description></item><item><title>Linux下常用软件配置</title><link>https://blog.mylab.top/post/linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 03 Apr 2021 18:18:27 +0800</pubDate><guid>https://blog.mylab.top/post/linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/</guid><description>Samba 安装 1 sudo apt install samba 修改配置文件 1 2 3 4 5 6 [share] path = /home/xyz/share/ create mask = 0664 directory mask = 0775 writable = yes valid users = xyz 其中:
[share]是你共享出来文件夹的名称 create mask 设置的是当新文件创建时的权限(该配置为664权限) directory mask 设置的是当新文件夹创建时的权限(该配置为664权限) valid users 表示只有名单内的用户才有权限访问 配置一个guest只读的共享:
1 2 3 4 [latest_qfil] path = /mnt/build/artifact/latest writable = no guest ok = yes 添加用户 1 sudo smbpasswd -a xyz 用户xyz必须是系统中存在的用户,和当前用户没有关系.</description></item><item><title>Sysfs Bin Attribute Demo</title><link>https://blog.mylab.top/post/sysfs-bin-attribute-demo/</link><pubDate>Sat, 03 Apr 2021 17:30:37 +0800</pubDate><guid>https://blog.mylab.top/post/sysfs-bin-attribute-demo/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 static ssize_t util_string_read(struct file *filp, struct kobject *kobj, struct bin_attribute *attr, char *buf, loff_t off, size_t count) { struct device *dev = kobj_to_dev(kobj); struct pci_dev *pdev = to_pci_dev(dev); struct zpci_dev *zdev = to_zpci(pdev); return memory_read_from_buffer(buf, count, &amp;amp;off, zdev-&amp;gt;util_str, sizeof(zdev-&amp;gt;util_str)); } static BIN_ATTR_RO(util_string, CLP_UTIL_STR_LEN); static struct bin_attribute *zpci_bin_attrs[] = { &amp;amp;bin_attr_util_string, NULL, }; static struct attribute_group zpci_attr_group = { .</description></item><item><title>Linux命令技巧</title><link>https://blog.mylab.top/post/linux%E5%91%BD%E4%BB%A4%E6%8A%80%E5%B7%A7/</link><pubDate>Sat, 03 Apr 2021 16:05:29 +0800</pubDate><guid>https://blog.mylab.top/post/linux%E5%91%BD%E4%BB%A4%E6%8A%80%E5%B7%A7/</guid><description>tar 1.压缩文件夹时忽略.git 1 tar --exclude-vcs -zcvf foo.tar.gz ./FOLDER_NAME https://unix.stackexchange.com/questions/18657/tar-a-folder-without-git-files
2.多线程压缩 使用pigz实现多线程压缩
1 2 3 4 tar --use-compress-program=&amp;#34;pigz --best --recursive&amp;#34; -cf archive.tar.gz YourData # 显示压缩进度 tar --use-compress-program=&amp;#34;pigz --best --recursive | pv&amp;#34; -cf archive.tar.gz YourData https://stackoverflow.com/questions/36917882/how-to-use-pigz-with-tar
wget 命令 将下载的结果输出到命令行：
1 2 3 wget -qO- http://whatever.com/page.php # 或者 wget -qO /dev/null http://whatever.com/page.php https://superuser.com/questions/321240/how-do-you-redirect-wget-response-to-standard-out
运行来自url的shell脚本 以下命令仅在bash中测试过：
不带参数：
1 2 3 4 5 6 7 curl -sSL http://mywebsite.</description></item><item><title>Shell中的常用语法</title><link>https://blog.mylab.top/post/shell%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</link><pubDate>Sat, 03 Apr 2021 15:40:17 +0800</pubDate><guid>https://blog.mylab.top/post/shell%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</guid><description>获取文件名/文件扩展名 1 2 3 4 5 6 7 8 9 ~% FILE=&amp;#34;example.tar.gz&amp;#34; ~% echo &amp;#34;${FILE%%.*}&amp;#34; example ~% echo &amp;#34;${FILE%.*}&amp;#34; example.tar ~% echo &amp;#34;${FILE#*.}&amp;#34; tar.gz ~% echo &amp;#34;${FILE##*.}&amp;#34; gz https://stackoverflow.com/questions/965053/extract-filename-and-extension-in-bash
去除字符串的前缀/后缀 有一个字符串为hello-world, 现在希望去除前缀hell和后缀ld, 得到新的字符串o-wor
1 2 3 string=&amp;#34;hello-world&amp;#34; prefix=&amp;#34;hell&amp;#34; suffix=&amp;#34;ld&amp;#34; 方法如下:
1 2 3 4 $ foo=${string#&amp;#34;$prefix&amp;#34;} $ foo=${foo%&amp;#34;$suffix&amp;#34;} $ echo &amp;#34;${foo}&amp;#34; o-wor https://stackoverflow.com/questions/16623835/remove-a-fixed-prefix-suffix-from-a-string-in-bash
手动向stderr输出 1 &amp;gt;&amp;amp;2 echo &amp;#34;error&amp;#34; https://stackoverflow.</description></item><item><title>Ubuntu挂载远程目录</title><link>https://blog.mylab.top/post/ubuntu%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/</link><pubDate>Sat, 03 Apr 2021 15:20:33 +0800</pubDate><guid>https://blog.mylab.top/post/ubuntu%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/</guid><description>挂载samba 安装cifs-utils 1 sudo apt-get install cifs-utils 手动挂载 1 2 # 注意这里的samba地址以&amp;#39;/&amp;#39;分隔， 不是&amp;#39;\&amp;#39; sudo mount -t cifs -o user=test@demo.com //192.168.1.1/my_share /mnt/samba fstab 1 //192.168.1.1/my_share /mnt/samba cifs user=test@demo.com,pass=123 0 0 参考:
https://support.zadarastorage.com/hc/en-us/articles/213024986-How-to-Mount-a-SMB-Share-in-Ubuntu 挂载sshfs 安装sshfs 1 sudo apt-get install sshfs 手动挂载 1 sudo sshfs -o allow_other root@xxx.xxx.xxx.xxx:/ /mnt/droplet 还可以指定密钥
1 sudo sshfs -o allow_other,IdentityFile=~/.ssh/id_rsa root@xxx.</description></item><item><title>Linux国内源</title><link>https://blog.mylab.top/post/linux%E5%9B%BD%E5%86%85%E6%BA%90/</link><pubDate>Sat, 03 Apr 2021 12:26:52 +0800</pubDate><guid>https://blog.mylab.top/post/linux%E5%9B%BD%E5%86%85%E6%BA%90/</guid><description>地址 名称 地址 腾讯云 mirrors.tencent.com 腾讯云(内网) mirrors.tencentyun.com 清华 mirrors.tuna.tsinghua.edu.cn USTC mirrors.ustc.edu.cn 阿里云 mirrors.aliyun.com 版本 Ubuntu版本 名称 20.04 focal 18.04 bionic 16.04 xenial Debian版本 名称 11 bullseye 10 buster 9 stretch latest stable stable sources.</description></item><item><title>Ubuntu设置动态IP与静态IP</title><link>https://blog.mylab.top/post/ubuntu%E8%AE%BE%E7%BD%AE%E5%8A%A8%E6%80%81ip%E4%B8%8E%E9%9D%99%E6%80%81ip/</link><pubDate>Sat, 03 Apr 2021 12:14:23 +0800</pubDate><guid>https://blog.mylab.top/post/ubuntu%E8%AE%BE%E7%BD%AE%E5%8A%A8%E6%80%81ip%E4%B8%8E%E9%9D%99%E6%80%81ip/</guid><description>动态IP cat /etc/netplan/01-netcfg.yaml
1 2 3 4 5 6 7 8 # This file describes the network interfaces available on your system # For more information, see netplan(5). network: version: 2 renderer: networkd ethernets: eth0: dhcp4: yes 静态IP cat /etc/netplan/01-netcfg.yaml
1 2 3 4 5 6 7 8 9 10 11 12 # This file describes the network interfaces available on your system # For more information, see netplan(5).</description></item><item><title>在Gerrit上建立Android代码仓库</title><link>https://blog.mylab.top/post/%E5%9C%A8gerrit%E4%B8%8A%E5%BB%BA%E7%AB%8Bandroid%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/</link><pubDate>Fri, 02 Apr 2021 13:30:57 +0800</pubDate><guid>https://blog.mylab.top/post/%E5%9C%A8gerrit%E4%B8%8A%E5%BB%BA%E7%AB%8Bandroid%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/</guid><description>1 2 3 4 5 6 7 8 GIT_USR=gerrit-admin GERRIT_HOST=192.168.1.1 PARENT_REPO=aosp-parent-repo GERRIT_REPO_OWNER_GRP=aosp-admin repo forall -vc &amp;#39;ssh -p 29418 $GIT_USR@$GERRIT_HOST gerrit create-project --owner $GERRIT_REPO_OWNER_GRP $REPO_PROJECT;&amp;#39; repo forall -vc &amp;#39;ssh -p 29418 $GIT_USR@$GERRIT_HOST gerrit set-project-parent --parent $PARENT_REPO $REPO_PROJECT;&amp;#39; repo forall -c &amp;#39;git push ssh://$GIT_USR@$GERRIT_HOST:29418/$REPO_PROJECT +refs/heads/* +refs/tags/*&amp;#39;</description></item><item><title>LVM使用记录</title><link>https://blog.mylab.top/post/lvm%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 02 Apr 2021 11:28:31 +0800</pubDate><guid>https://blog.mylab.top/post/lvm%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</guid><description>在新的硬盘/分区上使用lvm 1.创建新分区 1 2 3 4 5 6 # 创建sda1 fdisk /dev/sda g n ... w 2.创建PV 1 pvcreate /dev/sda1 3.创建VG 1 2 3 4 5 # vg1为VG的名称, sda1为之前创建好的PV vgcreate vg1 /dev/sda1 # 同时添加多块硬盘 vgcreate vg1 /dev/sda1 /dev/sdb1 4.创建LV 1 2 3 4 # 创建大小为10G, 名为test1的LV # vg1为之前创建的VG名称 lvcreate -L 10G -n &amp;#34;test1&amp;#34; vg1 这一步完成后, 会创建一个新的硬盘/dev/vg1/test1
5.格式化新创建的硬盘 1 mkfs.</description></item><item><title>Test</title><link>https://blog.mylab.top/post/test/</link><pubDate>Fri, 02 Apr 2021 01:10:56 +0800</pubDate><guid>https://blog.mylab.top/post/test/</guid><description>中文测试 这是中文测试
代码测试 1 2 3 4 5 6 #include &amp;lt;stdio.h&amp;gt;int main(void) { printf(&amp;#34;Hello, world!\n&amp;#34;); return 0; }</description></item></channel></rss>