{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Hao Lingjie","url":"https://lingjiehao.github.io","root":"/"},"pages":[{"title":"","date":"2020-07-21T04:04:01.800Z","updated":"2020-07-21T04:04:01.800Z","comments":false,"path":"categories/index.html","permalink":"https://lingjiehao.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-07-21T04:04:01.800Z","updated":"2020-07-21T04:04:01.800Z","comments":false,"path":"tags/index.html","permalink":"https://lingjiehao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"aria2添加开机自启动","slug":"aria2添加开机自启动","date":"2019-09-01T03:16:46.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/09/01/aria2添加开机自启动/","link":"","permalink":"https://lingjiehao.github.io/2019/09/01/aria2添加开机自启动/","excerpt":"","text":"在/etc/rc.local的exit 0前添加一句 aria2c –conf-path=/home/michael/.aria2/aria2.conf -D 另附aria2的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081dir=/data/_dlon-download-complete=/conf/on-complete.shinput-file=/conf/aria2.sessionsave-session=/conf/aria2.sessionrpc-secret=[RPC密码]log-level=warnenable-http-pipelining=truedisable-ipv6=true#允许rpcenable-rpc=true#允许所有来源, web界面跨域权限需要rpc-allow-origin-all=true#允许非外部访问rpc-listen-all=true#RPC端口, 仅当默认端口被占用时修改rpc-listen-port=6800#最大同时下载数(任务数), 路由建议值: 3max-concurrent-downloads=10#断点续传continue=true#同服务器连接数max-connection-per-server=10#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要min-split-size=10M#单文件最大线程数, 路由建议值: 5split=10#下载速度限制max-overall-download-limit=0#单文件速度限制max-download-limit=0#上传速度限制max-overall-upload-limit=0#单文件速度限制max-upload-limit=0#断开速度过慢的连接#lowest-speed-limit=0#验证用，需要1.16.1之后的release版本#referer=*#定时保存会话，需要1.16.1之后的release版save-session-interval=60#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本#disk-cache=0#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)#enable-mmap=true#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长#所需时间 none &lt; falloc ? trunc &lt;&lt; prealloc, falloc和trunc需要文件系统和内核支持file-allocation=falloc#启用本地节点查找bt-enable-lpd=true#添加额外的tracker#bt-tracker=,…#单种子最大连接数#bt-max-peers=55#强制加密, 防迅雷必备#bt-require-crypto=true#当下载的文件是一个种子(以.torrent结尾)时, 自动下载BTfollow-torrent=true#BT监听端口, 当端口屏蔽时使用listen-port=53247#不确定是否需要，为保险起见，need more testenable-dht=falsebt-enable-lpd=falseenable-peer-exchange=false#修改特征user-agent=uTorrent/2210(25130)peer-id-prefix=-UT2210-#修改做种设置, 允许做种seed-ratio=1seed-time=5000#保存会话force-save=truebt-hash-check-seed=truebt-seed-unverified=truebt-save-metadata=true","categories":[],"tags":[]},{"title":"docker","slug":"docker","date":"2019-08-05T01:12:18.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/08/05/docker/","link":"","permalink":"https://lingjiehao.github.io/2019/08/05/docker/","excerpt":"","text":"前言本文记录我在学习使用Docker中遇到的小问题, 我的环境是Ubuntu 16.04 安装可以使用Docker官方推荐的方法 curl -sSL get.docker.com | sudo sh 当然, Ubuntu的软件仓库中也是有docker的,可以直接使用apt安装 apt install docker.io","categories":[],"tags":[]},{"title":"git","slug":"git","date":"2019-07-09T18:58:21.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/07/09/git/","link":"","permalink":"https://lingjiehao.github.io/2019/07/09/git/","excerpt":"","text":"git shallow clone使用--depth参数可以只克隆部分commit历史 git clone –depth=1 https://github.com/MiCode/Xiaomi_Kernel_OpenSource.git git clone –depth=1 获取完整仓库 git clone –depth=1 https://github.com/MiCode/Xiaomi_Kernel_OpenSource.gitcd Xiaomi_Kernel_OpenSourcegit remote set-branches origin ‘*’git fetch –depth=1 -v 或者在.git/config中做如下修改 123456789101112[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote \"origin\"] url = https://github.com/MiCode/Xiaomi_Kernel_OpenSource.git- fetch = +refs/heads/master:refs/remotes/origin/master+ fetch = +refs/heads/*:refs/remotes/origin/*[branch \"README\"] remote = origin merge = refs/heads/README","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://lingjiehao.github.io/tags/git/"}]},{"title":"input子系统分析——以synaptics_dsx TP驱动为例","slug":"input子系统分析——以synaptics-dsx-TP驱动为例","date":"2019-07-05T02:16:03.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/07/05/input子系统分析——以synaptics-dsx-TP驱动为例/","link":"","permalink":"https://lingjiehao.github.io/2019/07/05/input子系统分析——以synaptics-dsx-TP驱动为例/","excerpt":"","text":"前言本文所分析的代码基于Qualcomm的开源代码, 内核版本为msm-4.4, 代码地址为: https://source.codeaurora.org/quic/la/kernel/msm-4.4/tree/?h=LA.UM.7.2.r1-07000-sdm660.0 ##","categories":[],"tags":[{"name":"TP","slug":"TP","permalink":"https://lingjiehao.github.io/tags/TP/"},{"name":"Driver","slug":"Driver","permalink":"https://lingjiehao.github.io/tags/Driver/"},{"name":"Synaptics","slug":"Synaptics","permalink":"https://lingjiehao.github.io/tags/Synaptics/"},{"name":"TODO","slug":"TODO","permalink":"https://lingjiehao.github.io/tags/TODO/"}]},{"title":"cron","slug":"cron","date":"2019-07-04T00:37:38.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/07/04/cron/","link":"","permalink":"https://lingjiehao.github.io/2019/07/04/cron/","excerpt":"","text":"crontab -e12345678910111213141516171819202122# Edit this file to introduce tasks to be run by cron.# # Each task to run has to be defined through a single line# indicating with different fields when the task will be run# and what command to run for the task# # To define the time you can provide concrete values for# minute (m), hour (h), day of month (dom), month (mon),# and day of week (dow) or use &apos;*&apos; in these fields (for &apos;any&apos;).# # Notice that tasks will be started based on the cron&apos;s system# daemon&apos;s notion of time and timezones.# # Output of the crontab jobs (including errors) is sent through# email to the user the crontab file belongs to (unless redirected).# # For example, you can run a backup of all your user accounts# at 5 a.m every week with:# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/# # For more information see the manual pages of crontab(5) and cron(8)# # m h dom mon dow command 范例123456789每隔5秒执行一次：*/5 * * * * ?每隔1分钟执行一次：0 */1 * * * ?每天23点执行一次：0 0 23 * * ?每天凌晨1点执行一次：0 0 1 * * ?每月1号凌晨1点执行一次：0 0 1 1 * ?每月最后一天23点执行一次：0 0 23 L * ?每周星期天凌晨1点实行一次：0 0 1 ? * L在26分、29分、33分执行一次：0 26,29,33 * * * ?每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ? 参考https://www.cnblogs.com/maybo/p/5189617.html","categories":[],"tags":[]},{"title":"SSH","slug":"SSH","date":"2019-07-03T22:36:39.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/07/03/SSH/","link":"","permalink":"https://lingjiehao.github.io/2019/07/03/SSH/","excerpt":"","text":"ssh-copy-idssh-copy-id的作用是把本机的公钥拷贝到服务器上 ssh config新建一个~/.ssh/config文件 123456# Read more about SSH config files: https://linux.die.net/man/5/ssh_configHost abc # abc表示服务器的名字 HostName 12.34.56.78 # 服务器地址 User qwe # 用户名 Port 12345 # 端口号, 不设置则默认为22 # IdentityFile ~/.ssh/id_rsa # 指定连接这个服务器使用的私钥, SSH v2的默认私钥文件名为`~/.ssh/id_rsa` 和 `~/.ssh/id_dsa` 这样就可以使用 ssh abc直接登录,如果你的密钥和服务器的吻合,就实现了免密登录 参考文档https://linux.die.net/man/5/ssh_confighttps://deepzz.com/post/how-to-setup-ssh-config.html","categories":[],"tags":[]},{"title":"Android中编译单个内核模块","slug":"Android中编译单个内核模块","date":"2019-06-25T21:55:27.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/06/25/Android中编译单个内核模块/","link":"","permalink":"https://lingjiehao.github.io/2019/06/25/Android中编译单个内核模块/","excerpt":"","text":"环境: Ubuntu 16.04 + Android P源码源码路径: /home/michael/android_code需要编译的模块路径: 比如 /home/michael/test_module/, 内核模块文件名为test_module.c 那么只需要在/home/michael/test_module/中建立一个Makefile文件就可以编译这个模块了.Makefile的模板如下: 123456789101112131415161718obj-m += test_module.o# Android 源码路径SOURCE_PATH := /home/michael/android_src# kernel 的输出目录, &lt;product-name&gt; 因产品而异,下文同KDIR := $(SOURCE_PATH)/out/target/product/&lt;product-name&gt;/obj/KERNEL_OBJPWD :=$(shell pwd)KERNEL_CFLAGS := KCFLAGS=-mno-androidCROSS := $(SOURCE_PATH)/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/binall: $(MAKE) -C $(FLAGS) $(KDIR) ARCH=arm64 CROSS_COMPILE=$(CROSS)/aarch64-linux-android- M=$(PWD) $(FLAGS) $(KERNEL_CFLAGS) modulesclean: rm -f *.mod.c *.ko *.o .*.cmd *.symvers *.order rm -rf .tmp_versions 然后在/home/michael/test_module中输入make, 就会生成下面的文件 1234567891011121314151617181920212223242526michael@cd1cab25653e:~/test_module$ make/usr/bin/makex: line 20: build/envsetup.sh: No such file or directory/usr/bin/make2 -C /home/michael/android_code/out/target/product/&lt;product-name&gt;/obj/KERNEL_OBJ ARCH=arm64 CROSS_COMPILE=/home/michael/android_code/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android- M=/home/michael/test_module KCFLAGS=-mno-android modulesmake2[1]: Entering directory '/home/michael/android_code/out/target/product/&lt;product-name&gt;/obj/kernel/msm-4.4' CC [M] /home/michael/test_module/test_module.o Building modules, stage 2. MODPOST 1 modules CC /home/michael/test_module/test_module.mod.o LD [M] /home/michael/test_module/test_module.komake2[1]: Leaving directory '/home/michael/android_code/out/target/product/&lt;product-name&gt;/obj/kernel/msm-4.4'michael@cd1cab25653e:~/test_module$ ls -latotal 628drwxrwxr-x 3 michael michael 4096 Jun 26 14:14 .drwxr-xr-x 17 michael michael 4096 Jun 26 14:14 ..-rw-rw-r-- 1 michael michael 483 Jun 26 14:14 .test_module.ko.cmd-rw-rw-r-- 1 michael michael 41291 Jun 26 14:14 .test_module.mod.o.cmd-rw-rw-r-- 1 michael michael 51771 Jun 26 14:14 .test_module.o.cmddrwxrwxr-x 2 michael michael 4096 Jun 26 14:14 .tmp_versions-rw-rw-r-- 1 michael michael 492 Jun 26 14:14 Makefile-rw-rw-r-- 1 michael michael 0 Jun 26 14:14 Module.symvers-rw-rw-r-- 1 michael michael 52 Jun 26 14:14 modules.order-rw-rw-r-- 1 michael michael 10276 May 30 11:14 test_module.c-rw-rw-r-- 1 michael michael 247216 Jun 26 14:14 test_module.ko-rw-rw-r-- 1 michael michael 2277 Jun 26 14:14 test_module.mod.c-rw-rw-r-- 1 michael michael 83424 Jun 26 14:14 test_module.mod.o-rw-rw-r-- 1 michael michael 165320 Jun 26 14:14 test_module.o 我目前编译的模块都是单文件的,多文件还未尝试,以后遇到编译多文件的时候会更新.","categories":[],"tags":[]},{"title":"Mount RAW file in Ubuntu","slug":"Mount-RAW-file-in-Ubuntu","date":"2019-06-06T20:43:46.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/06/06/Mount-RAW-file-in-Ubuntu/","link":"","permalink":"https://lingjiehao.github.io/2019/06/06/Mount-RAW-file-in-Ubuntu/","excerpt":"","text":"本文主要讲解如何在Ubuntu下挂载raw image镜像，以raspberry pi官方镜像2019-04-08-raspbian-stretch-lite.img 为例 手动挂载 使用fdisk查看分区结构 123456789101112# fdisk -lDisk 2019-04-08-raspbian-stretch-lite.img: 1.7 GiB, 1803550720 bytes, 3522560 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0xc1dc39e5Device Boot Start End Sectors Size Id Type2019-04-08-raspbian-stretch-lite.img1 8192 96042 87851 42.9M c W95 FA2019-04-08-raspbian-stretch-lite.img2 98304 3522559 3424256 1.6G 83 Linux 可以看出，这份镜像的sectors size = 512 bytes，而第一个分区的偏移量是8192 sectors，故偏移的字节为512 * 8192 = 4194304 bytes，下面用mount命令挂载 1# mount -o offset=4194304 2019-04-08-raspbian-stretch-lite.img tmp/ 第二个分区同理 自动挂载可以使用losetup这个工具自动挂载 1# losetup -f -P 2019-04-08-raspbian-stretch-lite.img 查看挂载结果 123$ losetup -lNAME SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE DIO LOG-SEC/dev/loop0 0 0 0 0 /home/michael/Downloads/2019-04-08-raspbian-stretch-lite.img 0 512 或者使用lsblk查看 12345$ lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTloop0 7:0 0 1.7G 0 loop ├─loop0p1 259:6 0 42.9M 0 loop └─loop0p2 259:7 0 1.6G 0 loop 挂载 1# mount /dev/loop0p1 tmp 附上losetup的参数说明 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$ losetup --helpUsage: losetup [options] [&lt;loopdev&gt;] losetup [options] -f | &lt;loopdev&gt; &lt;file&gt;Set up and control loop devices.Options: -a, --all list all used devices -d, --detach &lt;loopdev&gt;... detach one or more devices -D, --detach-all detach all used devices -f, --find find first unused device -c, --set-capacity &lt;loopdev&gt; resize the device -j, --associated &lt;file&gt; list all devices associated with &lt;file&gt; -L, --nooverlap avoid possible conflict between devices -o, --offset &lt;num&gt; start at offset &lt;num&gt; into file --sizelimit &lt;num&gt; device is limited to &lt;num&gt; bytes of the file -b --sector-size &lt;num&gt; set the logical sector size to &lt;num&gt; -P, --partscan create a partitioned loop device -r, --read-only set up a read-only loop device --direct-io[=&lt;on|off&gt;] open backing file with O_DIRECT --show print device name after setup (with -f) -v, --verbose verbose mode -J, --json use JSON --list output format -l, --list list info about all or specified (default) -n, --noheadings don&apos;t print headings for --list output -O, --output &lt;cols&gt; specify columns to output for --list --raw use raw --list output format -h, --help display this help -V, --version display versionAvailable output columns: NAME loop device name AUTOCLEAR autoclear flag set BACK-FILE device backing file BACK-INO backing file inode number BACK-MAJ:MIN backing file major:minor device number MAJ:MIN loop device major:minor number OFFSET offset from the beginning PARTSCAN partscan flag set RO read-only device SIZELIMIT size limit of the file in bytes DIO access backing file with direct-io LOG-SEC logical sector size in bytesFor more details see losetup(8). 参考链接https://major.io/2010/12/14/mounting-a-raw-partition-file-made-with-dd-or-dd_rescue-in-linux/ https://blog.tinned-software.net/mount-raw-image-of-entire-disc/","categories":[],"tags":[]},{"title":"Ubuntu Postinstall Tips","slug":"Ubuntu-Postinstall-Tips","date":"2019-06-04T05:59:09.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/06/04/Ubuntu-Postinstall-Tips/","link":"","permalink":"https://lingjiehao.github.io/2019/06/04/Ubuntu-Postinstall-Tips/","excerpt":"","text":"Ubuntu16.04修改时区 dpkg-reconfigure tzdata Ubuntu安装Chrome64bit: wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 32bit: wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb Then: dpkg -i xxx.deb Dual Boot: Fix Time Differences Between Ubuntu And WindowsFor Ubuntu 16.04 and newer, run the following command: timedatectl set-local-rtc 1 Grub remember chosenModify /etc/default/grub GRUB_DEFAULT=savedGRUB_SAVEDEFAULT=true Then update-grub","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2019-05-23T21:33:45.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/05/23/test/","link":"","permalink":"https://lingjiehao.github.io/2019/05/23/test/","excerpt":"","text":"This article is for test.","categories":[],"tags":[{"name":"test","slug":"test","permalink":"https://lingjiehao.github.io/tags/test/"}]},{"title":"Ubuntu 16.04下Android O编译环境的搭建","slug":"Ubuntu-16-04下Android-O编译环境的搭建","date":"2019-05-23T18:45:58.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/05/23/Ubuntu-16-04下Android-O编译环境的搭建/","link":"","permalink":"https://lingjiehao.github.io/2019/05/23/Ubuntu-16-04下Android-O编译环境的搭建/","excerpt":"","text":"网上关于安卓编译环境搭建的文章有不少，但质量参差不齐，关于安装哪些软件各有各的说法，这样带来的后果是如果编译出错了，就眉毛胡子一把抓，把所有人说的所有的软件都安装上去，这样有可能带来的问题会更多。 我搭建编译境的时候幸运地在DigitalOcean上找到了一篇详细介绍安卓编译环境搭建的文章,了解DigitalOcean的人都知道他家的文章质量很高，这篇也不例外，我按照文中的方法搭建后，在AOSP8.1以及公司的代码上都是一次编译成功。 以下是简单的安装记录，详细介绍请参考原文。 安装repo1sudo apt install repo 配置git的email和username12git config --global user.name \"your name\"git config --global user.email \"mailto:your_email@your_domain.com\" 安装编译所需的软件包1sudo apt-get install openjdk-8-jdk android-tools-adb bc bison build-essential curl flex g++-multilib gcc-multilib gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev libesd0-dev liblz4-tool libncurses5-dev libsdl1.2-dev libssl-dev libwxgtk3.0-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc yasm zip zlib1g-dev 上面三步完成后就可以拉代码编译了，关于如何使用repo拉代码，如何编译不再本文讨论的范围内。 下面两步是独立的且可选的 使用ccache加快每次重新编译的速度下载ccache（注：原文中不是使用apt安装ccache的，而是使用源码中自带ccache，我在源码中没找到，所以使用apt安装了ccache） 修改ccache所使用的缓存大小ccache默认使用的缓存最大值为1G，原文推荐修改为15G，你当然可以设置更大的缓存空间，ccache生成的缓存默认位于用户主目录的.ccache目录下。 1ccache -M 15G 添加环境变量1export USE_CCACHE=1 为了永久生效，你可以把上面这句话添加到.bashrc中（如果你使用bash的话）。 限制Jack Server的内存使用1export ANDROID_JACK_VM_ARGS=\"-Xmx8g -Dfile.encoding=UTF-8 -XX:+TieredCompilation\"","categories":[],"tags":[]},{"title":"vim","slug":"vim","date":"2019-05-23T18:40:26.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/05/23/vim/","link":"","permalink":"https://lingjiehao.github.io/2019/05/23/vim/","excerpt":"","text":"增加支持lua sudo apt install vim-nox 参考: https://github.com/Shougo/neocomplete.vim 在Ubuntu 16.04上安装vim8 sudo add-apt-repository ppa:jonathonf/vim -y \\&amp;&amp; sudo apt update -y \\&amp;&amp; sudo apt install vim -y","categories":[],"tags":[]},{"title":"Ubuntu KVM搭建","slug":"Ubuntu-KVM搭建","date":"2019-05-23T18:19:59.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/05/23/Ubuntu-KVM搭建/","link":"","permalink":"https://lingjiehao.github.io/2019/05/23/Ubuntu-KVM搭建/","excerpt":"","text":"本文参考文章:KVM/Installation","categories":[],"tags":[]},{"title":"Ubuntu查看crontab运行日志","slug":"Ubuntu查看crontab运行日志","date":"2019-05-22T01:39:55.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/05/22/Ubuntu查看crontab运行日志/","link":"","permalink":"https://lingjiehao.github.io/2019/05/22/Ubuntu查看crontab运行日志/","excerpt":"","text":"修改rsyslog12sudo vim /etc/rsyslog.d/50-default.confcron.* /var/log/cron.log #将cron前面的注释符去掉 重启rsyslog1sudo service rsyslog restart 查看crontab日志1tail -f /var/log/cron.log","categories":[],"tags":[{"name":"crontab","slug":"crontab","permalink":"https://lingjiehao.github.io/tags/crontab/"},{"name":"log","slug":"log","permalink":"https://lingjiehao.github.io/tags/log/"}]},{"title":"adb获取手机温度","slug":"adb获取手机温度","date":"2019-05-22T01:37:09.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/05/22/adb获取手机温度/","link":"","permalink":"https://lingjiehao.github.io/2019/05/22/adb获取手机温度/","excerpt":"","text":"存储温度信息的节点在/sys/class/thermal/目录下，其中thermal_zone*为各传感器对应的文件夹，thermal_zone*下有type节点指明该传感器的位置，temp节点代表温度。直接cat这些节点就可以得到相应的信息。","categories":[],"tags":[{"name":"Thermal","slug":"Thermal","permalink":"https://lingjiehao.github.io/tags/Thermal/"}]},{"title":"Something about DTB...","slug":"Something-about-DTB","date":"2019-05-21T23:59:08.000Z","updated":"2020-07-21T04:04:01.800Z","comments":true,"path":"2019/05/21/Something-about-DTB/","link":"","permalink":"https://lingjiehao.github.io/2019/05/21/Something-about-DTB/","excerpt":"","text":"相关工具 mkdtimg - out/host/linux-x86/bin 将dtb分区转换为dtb文件1mkdtimg dump &lt;image_file&gt; -b &lt;output_file&gt; 这里的 &lt;image_file&gt; 代表dtb/dtbo block, 可以使用dd命令或者cp命令获得; &lt;output_file&gt; 代表你想要的名字. dtc - out/host/linux-x86/bin 将dtb反编译为dts1dtc -I dtb -O dts &lt;dtb_file&gt; -o &lt;output_file&gt; 这里的指的是dtb文件,而不是dtb block 一些重要的参考资料 dt-object-internal.txt","categories":[],"tags":[]}]}