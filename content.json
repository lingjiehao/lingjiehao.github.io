{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Hao Lingjie","url":"https://lingjiehao.github.io","root":"/"},"pages":[{"title":"","date":"2020-07-21T04:04:01.800Z","updated":"2020-07-21T04:04:01.800Z","comments":false,"path":"categories/index.html","permalink":"https://lingjiehao.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-07-21T04:04:01.800Z","updated":"2020-07-21T04:04:01.800Z","comments":false,"path":"tags/index.html","permalink":"https://lingjiehao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android中编译单个内核模块","slug":"Android中编译单个内核模块","date":"2019-06-25T21:55:27.000Z","updated":"2020-07-21T12:42:35.694Z","comments":true,"path":"2019/06/25/Android中编译单个内核模块/","link":"","permalink":"https://lingjiehao.github.io/2019/06/25/Android中编译单个内核模块/","excerpt":"","text":"环境: Ubuntu 16.04 + Android P源码源码路径: /home/michael/android_code需要编译的模块路径: 比如 /home/michael/test_module/, 内核模块文件名为test_module.c 那么只需要在/home/michael/test_module/中建立一个Makefile文件就可以编译这个模块了.Makefile的模板如下: 123456789101112131415161718obj-m += test_module.o# Android 源码路径SOURCE_PATH := /home/michael/android_src# kernel 的输出目录, &lt;product-name&gt; 因产品而异,下文同KDIR := $(SOURCE_PATH)/out/target/product/&lt;product-name&gt;/obj/KERNEL_OBJPWD :=$(shell pwd)KERNEL_CFLAGS := KCFLAGS=-mno-androidCROSS := $(SOURCE_PATH)/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/binall: $(MAKE) -C $(FLAGS) $(KDIR) ARCH=arm64 CROSS_COMPILE=$(CROSS)/aarch64-linux-android- M=$(PWD) $(FLAGS) $(KERNEL_CFLAGS) modulesclean: rm -f *.mod.c *.ko *.o .*.cmd *.symvers *.order rm -rf .tmp_versions 然后在/home/michael/test_module中输入make, 就会生成下面的文件 1234567891011121314151617181920212223242526michael@cd1cab25653e:~/test_module$ make/usr/bin/makex: line 20: build/envsetup.sh: No such file or directory/usr/bin/make2 -C /home/michael/android_code/out/target/product/&lt;product-name&gt;/obj/KERNEL_OBJ ARCH=arm64 CROSS_COMPILE=/home/michael/android_code/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android- M=/home/michael/test_module KCFLAGS=-mno-android modulesmake2[1]: Entering directory '/home/michael/android_code/out/target/product/&lt;product-name&gt;/obj/kernel/msm-4.4' CC [M] /home/michael/test_module/test_module.o Building modules, stage 2. MODPOST 1 modules CC /home/michael/test_module/test_module.mod.o LD [M] /home/michael/test_module/test_module.komake2[1]: Leaving directory '/home/michael/android_code/out/target/product/&lt;product-name&gt;/obj/kernel/msm-4.4'michael@cd1cab25653e:~/test_module$ ls -latotal 628drwxrwxr-x 3 michael michael 4096 Jun 26 14:14 .drwxr-xr-x 17 michael michael 4096 Jun 26 14:14 ..-rw-rw-r-- 1 michael michael 483 Jun 26 14:14 .test_module.ko.cmd-rw-rw-r-- 1 michael michael 41291 Jun 26 14:14 .test_module.mod.o.cmd-rw-rw-r-- 1 michael michael 51771 Jun 26 14:14 .test_module.o.cmddrwxrwxr-x 2 michael michael 4096 Jun 26 14:14 .tmp_versions-rw-rw-r-- 1 michael michael 492 Jun 26 14:14 Makefile-rw-rw-r-- 1 michael michael 0 Jun 26 14:14 Module.symvers-rw-rw-r-- 1 michael michael 52 Jun 26 14:14 modules.order-rw-rw-r-- 1 michael michael 10276 May 30 11:14 test_module.c-rw-rw-r-- 1 michael michael 247216 Jun 26 14:14 test_module.ko-rw-rw-r-- 1 michael michael 2277 Jun 26 14:14 test_module.mod.c-rw-rw-r-- 1 michael michael 83424 Jun 26 14:14 test_module.mod.o-rw-rw-r-- 1 michael michael 165320 Jun 26 14:14 test_module.o 我目前编译的模块都是单文件的,多文件还未尝试,以后遇到编译多文件的时候会更新.","categories":[],"tags":[]},{"title":"挂载img文件","slug":"挂载img文件","date":"2019-06-06T20:43:46.000Z","updated":"2020-07-21T12:38:16.051Z","comments":true,"path":"2019/06/06/挂载img文件/","link":"","permalink":"https://lingjiehao.github.io/2019/06/06/挂载img文件/","excerpt":"本文主要讲解如何在Ubuntu下挂载raw image镜像，以raspberry pi官方镜像2019-04-08-raspbian-stretch-lite.img 为例","text":"本文主要讲解如何在Ubuntu下挂载raw image镜像，以raspberry pi官方镜像2019-04-08-raspbian-stretch-lite.img 为例 手动挂载 使用fdisk查看分区结构 123456789101112# fdisk -lDisk 2019-04-08-raspbian-stretch-lite.img: 1.7 GiB, 1803550720 bytes, 3522560 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0xc1dc39e5Device Boot Start End Sectors Size Id Type2019-04-08-raspbian-stretch-lite.img1 8192 96042 87851 42.9M c W95 FA2019-04-08-raspbian-stretch-lite.img2 98304 3522559 3424256 1.6G 83 Linux 可以看出，这份镜像的sectors size = 512 bytes，而第一个分区的偏移量是8192 sectors，故偏移的字节为512 * 8192 = 4194304 bytes，下面用mount命令挂载 1# mount -o offset=4194304 2019-04-08-raspbian-stretch-lite.img tmp/ 第二个分区同理 自动挂载可以使用losetup这个工具自动挂载 1# losetup -f -P 2019-04-08-raspbian-stretch-lite.img 查看挂载结果 123$ losetup -lNAME SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE DIO LOG-SEC/dev/loop0 0 0 0 0 /home/michael/Downloads/2019-04-08-raspbian-stretch-lite.img 0 512 或者使用lsblk查看 12345$ lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTloop0 7:0 0 1.7G 0 loop├─loop0p1 259:6 0 42.9M 0 loop└─loop0p2 259:7 0 1.6G 0 loop 挂载 1# mount /dev/loop0p1 tmp 附上losetup的参数说明 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$ losetup --helpUsage: losetup [options] [&lt;loopdev&gt;] losetup [options] -f | &lt;loopdev&gt; &lt;file&gt;Set up and control loop devices.Options: -a, --all list all used devices -d, --detach &lt;loopdev&gt;... detach one or more devices -D, --detach-all detach all used devices -f, --find find first unused device -c, --set-capacity &lt;loopdev&gt; resize the device -j, --associated &lt;file&gt; list all devices associated with &lt;file&gt; -L, --nooverlap avoid possible conflict between devices -o, --offset &lt;num&gt; start at offset &lt;num&gt; into file --sizelimit &lt;num&gt; device is limited to &lt;num&gt; bytes of the file -b --sector-size &lt;num&gt; set the logical sector size to &lt;num&gt; -P, --partscan create a partitioned loop device -r, --read-only set up a read-only loop device --direct-io[=&lt;on|off&gt;] open backing file with O_DIRECT --show print device name after setup (with -f) -v, --verbose verbose mode -J, --json use JSON --list output format -l, --list list info about all or specified (default) -n, --noheadings don&apos;t print headings for --list output -O, --output &lt;cols&gt; specify columns to output for --list --raw use raw --list output format -h, --help display this help -V, --version display versionAvailable output columns: NAME loop device name AUTOCLEAR autoclear flag set BACK-FILE device backing file BACK-INO backing file inode number BACK-MAJ:MIN backing file major:minor device number MAJ:MIN loop device major:minor number OFFSET offset from the beginning PARTSCAN partscan flag set RO read-only device SIZELIMIT size limit of the file in bytes DIO access backing file with direct-io LOG-SEC logical sector size in bytesFor more details see losetup(8). 参考链接https://major.io/2010/12/14/mounting-a-raw-partition-file-made-with-dd-or-dd_rescue-in-linux/ https://blog.tinned-software.net/mount-raw-image-of-entire-disc/","categories":[],"tags":[]},{"title":"Ubuntu 16.04下Android O编译环境的搭建","slug":"Ubuntu-16-04下Android-O编译环境的搭建","date":"2019-05-23T18:45:58.000Z","updated":"2020-07-21T12:38:50.379Z","comments":true,"path":"2019/05/23/Ubuntu-16-04下Android-O编译环境的搭建/","link":"","permalink":"https://lingjiehao.github.io/2019/05/23/Ubuntu-16-04下Android-O编译环境的搭建/","excerpt":"网上关于安卓编译环境搭建的文章有不少，但质量参差不齐，关于安装哪些软件各有各的说法，这样带来的后果是如果编译出错了，就眉毛胡子一把抓，把所有人说的所有的软件都安装上去，这样有可能带来的问题会更多。 我搭建编译境的时候幸运地在DigitalOcean上找到了一篇详细介绍安卓编译环境搭建的文章,了解DigitalOcean的人都知道他家的文章质量很高，这篇也不例外，我按照文中的方法搭建后，在AOSP8.1以及公司的代码上都是一次编译成功。 以下是简单的安装记录，详细介绍请参考原文。","text":"网上关于安卓编译环境搭建的文章有不少，但质量参差不齐，关于安装哪些软件各有各的说法，这样带来的后果是如果编译出错了，就眉毛胡子一把抓，把所有人说的所有的软件都安装上去，这样有可能带来的问题会更多。 我搭建编译境的时候幸运地在DigitalOcean上找到了一篇详细介绍安卓编译环境搭建的文章,了解DigitalOcean的人都知道他家的文章质量很高，这篇也不例外，我按照文中的方法搭建后，在AOSP8.1以及公司的代码上都是一次编译成功。 以下是简单的安装记录，详细介绍请参考原文。 安装repo1sudo apt install repo 配置git的email和username12git config --global user.name \"your name\"git config --global user.email \"mailto:your_email@your_domain.com\" 安装编译所需的软件包1sudo apt-get install openjdk-8-jdk android-tools-adb bc bison build-essential curl flex g++-multilib gcc-multilib gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev libesd0-dev liblz4-tool libncurses5-dev libsdl1.2-dev libssl-dev libwxgtk3.0-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc yasm zip zlib1g-dev 上面三步完成后就可以拉代码编译了，关于如何使用repo拉代码，如何编译不再本文讨论的范围内。 下面两步是独立的且可选的 使用ccache加快每次重新编译的速度下载ccache（注：原文中不是使用apt安装ccache的，而是使用源码中自带ccache，我在源码中没找到，所以使用apt安装了ccache） 修改ccache所使用的缓存大小ccache默认使用的缓存最大值为1G，原文推荐修改为15G，你当然可以设置更大的缓存空间，ccache生成的缓存默认位于用户主目录的.ccache目录下。 1ccache -M 15G 添加环境变量1export USE_CCACHE=1 为了永久生效，你可以把上面这句话添加到.bashrc中（如果你使用bash的话）。 限制Jack Server的内存使用1export ANDROID_JACK_VM_ARGS=\"-Xmx8g -Dfile.encoding=UTF-8 -XX:+TieredCompilation\"","categories":[],"tags":[]}]}